import random

#Databases
#letters
a="a"
b="b"
c="c"
d="d"
e="e"
f="f"
g="g"
h="h"
i="i"
j="j"
k="k"
l="l"
m="m"
n="n"
o="o"
p="p"
q="q"
r="r"
s="s"
t="t"
u="u"
v="v"
w="w"
x="x"
y="y"
z="z"
#word list 
#0 element will dictate how many "_"s for letters
word =     [4,w,o,r,d,0,0,0,0,0,0,0]
hangman =  [7,h,a,n,g,m,a,n,0,0,0,0]
computer = [8,c,o,m,p,u,t,e,r,0,0,0]
party =    [5,p,a,r,t,y,0,0,0,0,0,0]
paper =    [5,p,a,p,e,r,0,0,0,0,0,0]
silver =   [6,s,i,l,v,e,r,0,0,0,0,0]
food =     [4,f,o,o,d,0,0,0,0,0,0,0]
#if the indexed value returns "0", abort checks and move on

#print(word[0]) #this works to access the element I was looking for
wordlist = [word,hangman,computer,party,paper,silver,food]

wrongcount = 0
bodycount = 0

head = ("   ")
arm = ("   ")
torso = (" ")
arm2 = (" ")
leg = ("  ")
leg2 = ("  ")
trapdoor = ("____")


position1 = ("_")
position2 = ("_")
position3 = ("_")
position4 = ("_")
position5 = ("_")
position6 = ("_")
position7 = ("_")
position8 = ("_")
position9 = ("_")

positions = [position1,position2,position3,position4,position5,position6,position7,position8,position9,0,0]

#there are 12 elements in the arrays for the words, need to make it so that the Positions array changes positions with spaces are equivelent to a 0 before comparing them. need to also make the positions array have at least 11 elements so that they come back the same.

print (positions)

#Functions
def openingsequence():
    print("Let's play Hangman!"), print("y/n")
    start = input()
    while(start) == "n":
        print("Okay, but come back when you want a challenge!")
        start = input()
    if(start) == "y":
        print("Do you know how to play?")
        print("y/n")
    tutorial = input()
    while(tutorial) == "n":
        print("Ok!")
        print("The object of the game is for you to guess the word I'm thinking of before an innocent man is hanged!But I am not fully evil, so I will give to the number of letters and show you where they are in the word. And I will give you as many tries as you want to guess a letter or to solve the puzzle before I send this man to his Doom. Beware that you only get 6 wrong answers before I pull the lever")
        print("Make sense?")
        print("y/n")
        tutorial = input()
        while(tutorial) == "n":
            print("I'm not sure how much clearer I can be. Try rereading it again. Does it make sense now?")
            print("y/n")
            tutorial = input()
        if(tutorial) == "y":
            print("     ")
    if(tutorial) == "y":
        print("Ok! Let's get started")
        print("Let me wake up the wizard and have him conjure the interface.")
    print("*Muffled Boot Kick* Wake up! We have a game to Play!")

def bodycounter():
    global bodycount
    bodycount = bodycount + 1
    return (bodycount) #this should increment the bodycount by 1 and update the global value
    
def wrongcounter():
    global wrongcount
    bodycount()
    wrongcount = wrongcount + 1
    return (wrongcount) #this should increment the wrongcount by 1 and update the global value

def coroner(): #takes bodycount and adjusts the body part variables appropriately
    global bodycount
    global head
    global torso
    global arm
    global arm2
    global leg
    global leg2
    global trapdoor
    if(bodycount) == 1:
        head = ("   O")
        return (head)
    if(bodycount) == 2:
        torso = ("|")
        return(torso)
    if(bodycount) == 3:
        arm = ("  /")
        return(arm)
    if(bodycount) == 4:
        arm2 = ("\ ")
        return(arm2)
    if(bodycount) == 5:
        leg = (" /")
        return(leg)
    if(bodycount) == 6:
        leg2 = (" \ ")
        return(leg2)
    if(bodycount) == 7:
        trapdoor = ("\   ")
        return(trapdoor)

def cremator(): #resets the body
    global head
    global torso
    global arm
    global arm2
    global leg
    global leg2
    global trapdoor
    head = ("   ")
    arm = ("   ")
    torso = (" ")
    arm2 = (" ")
    leg = ("  ")
    leg2 = ("  ")
    trapdoor = ("____")
    return(head)
    return(torso)
    return(arm)
    return(arm2)
    return(leg)
    return(leg2)
    return(trapdoor)

def num_of_letters():
    global position2
    global position3
    global position4
    global position5
    global position6
    global position7
    global position8
    global position9
    if(word_selection [0]) == 1: #this didn't hate me
        position2 = (" ")
        position3 = (" ")
        position4 = (" ")
        position5 = (" ")
        position6 = (" ")
        position7 = (" ")
        position8 = (" ")
        position9 = (" ")
        return position2
        return position3
        return position4
        return position5
        return position6
        return position7
        return position8
        return position9
    if(word_selection [0]) == 2:
        position3 = (" ")
        position4 = (" ")
        position5 = (" ")
        position6 = (" ")
        position7 = (" ")
        position8 = (" ")
        position9 = (" ")
        return position3
        return position4
        return position5
        return position6
        return position7
        return position8
        return position9
    if(word_selection [0]) == 3:
        position4 = (" ")
        position5 = (" ")
        position6 = (" ")
        position7 = (" ")
        position8 = (" ")
        position9 = (" ")
        return position4
        return position5
        return position6
        return position7
        return position8
        return position9
    if(word_selection [0]) == 4:
        position5 = (" ")
        position6 = (" ")
        position7 = (" ")
        position8 = (" ")
        position9 = (" ")
        return position5
        return position6
        return position7
        return position8
        return position9
    if(word_selection [0]) == 5:
        position6 = (" ")
        position7 = (" ")
        position8 = (" ")
        position9 = (" ")
        return position6
        return position7
        return position8
        return position9
    if(word_selection [0]) == 6:
        position7 = (" ")
        position8 = (" ")
        position9 = (" ")
        return position7
        return position8
        return position9
    if(word_selection [0]) == 7:
        position8 = (" ")
        position9 = (" ")
        return position8
        return position9
    if(word_selection [0]) == 8:
        position9 = (" ") 
        return position9
    if(word_selection [0]) == 9:
        print(" ")
    
def underscoreupdater(): #flip "_" to the corectly guessed letter based on the specific element for a specific position
    global position1
    global position2
    global position3
    global position4
    global position5
    global position6
    global position7
    global position8
    global position9
    

def interface():
    print("             _________"), print("             |         |"), print("             |      "+ str(head)), print("             |      "+arm+torso+arm2), print("             |       "+leg+leg2), print("             |"), print("     _________________"+trapdoor+"_________"), print(" "), print("                  "), print(position1+" "+position2+" "+position3+" "+position4+" "+position5+" "+position6+" "+position7+" "+position8+" "+position9), print(" ")

def tryagain(): #Might need to take out word_selection 
    global wrongcount
    global bodycount
    global word_selection
    print("Try again?")
    print("y/n")
    tryagain = input ()
    if(tryagain) == "y":
        cremator()
        wrongcount = 0
        bodycount = 0
        word_selection = random.choice (wordlist)
        return wrongcount
        return bodycount
        return word_selection
        #interface()
    #tryagain needs to reset wrongcounter to 0 and revert the bodycounter to 0. Then pick a new word from the list, reset the position counter to the value in the 0element, print interface, and then ask for the first guess.
    if(tryagain) == "n":
        print("No worries! I'll be waiting for you.")

def letterguess():
    global positions #letterguess should do something with the input to make it so that each letter you guess either changes in the positions or adds to the bodycount
    
def compare_arrays():
    for i in range(11):
        if positions[i] != word_selection[i + 1]:
            return False
        else:
            return True


def playtime():
    global bodycounter
    global wrongcounter 
    global coroner
    global word_selection
    global positions # need to build an array that is made out of the positions
    #while wordselection != positions: #need to get the positions and word selection to line up and compare themselves. Or just use the information that gemini gave me on how to run the game
    ''' possible solution from gemini
    def compare_arrays(array1, array2):
    """Compares elements 0-4 of array1 to elements 1-5 of array2.

    Args:
        array1: The first array.
        array2: The second array.

    Returns:
        True if the corresponding elements are equal, False otherwise.
    """

    if len(array1) < 5 or len(array2) < 5: #dont think I need this one as long as I make sure the arrays are the same without counting the 0 element in the wordlists
        return False

    for i in range(11):
        if positions[i] != word_selection[i + 1]:
            return False
        else:
            return True

# Example usage:
array1 = [1, 2, 3, 4, 5]
array2 = [0, 1, 2, 3, 4, 5]
result = compare_arrays(array1, array2)
print(result)  # Output: True'''
       # letterguess=input
       # if letterguess == "a":
        #    letterguess()
        # if not 












#hangman game
 
word_selection = random.choice (wordlist)
print(word_selection)
print(" I've chosen a word")
num_of_letters()
interface()
print (wrongcount)
print (bodycount)
tryagain()
print (wrongcount)
print (bodycount)
print(word_selection)


    
#print("             _________"), print("             |         |"), print("             |      "+ str(head)), print("             |      "+arm+torso+arm2), print("             |       "+leg+leg2), print("             |"), print("     _________________"+trapdoor+"_________"), print(" "), print("                  "), print(position1+" "+position2+" "+position3+" "+position4+" "+position5+" "+position6+" "+position7+" "+position8+" "+position9), print(" ")

#test input
wrong = 20 #input()
#need a solve input

#All body count advancement is here
#They all end with a wrongcounter going up. Might need to start them with the wrongcounter, I'm not sure. I just feel like this is going to be a source of frustration later
#I need to rebuild this so that if returns a counter from the wrong guess. And then build the counter to update the head variable in global scope. basically split this into 2 different funtions that just returns a single thing each
if(wrong) == "wr":
    wrongcount = wrongcount + 1
    if(wrongcount) == 1:
        head = ("   O")
        interface()
        wrong = input()
        print(" ")
        if(wrong) == "wr":
            wrongcount = wrongcount + 1
    if(wrongcount) == 2:
        torso = ("|")
        interface()
        wrong = input()
        print(" ")
        if(wrong) == "wr":
            wrongcount = wrongcount + 1
    if(wrongcount) == 3:
        arm = ("  /")
        interface()
        wrong = input()
        print(" ")
        if(wrong) == "wr":
            wrongcount = wrongcount + 1
    if(wrongcount) == 4:
        arm2 = ("\ ")
        interface()
        wrong = input()
        print(" ")
        if(wrong) == "wr":
            wrongcount = wrongcount + 1
    if(wrongcount) == 5:
        leg = (" /")
        interface()
        wrong = input()
        print(" ")
        if(wrong) == "wr":
            wrongcount = wrongcount + 1
    if(wrongcount) == 6:
        leg2 = (" \ ")
        interface()
        wrong = input()
        print(" ")
        if(wrong) == "wr":
            wrongcount = wrongcount + 1
    if(wrongcount) == 7:
        trapdoor = ("\   ")
        interface()
        wrongcount = wrongcount + 1
        print("*******Game over*******")
            
        





#def display_info(first_name, last_name):
    #print('First Name:', first_name)
    #print('Last Name:', last_name)
    
#display_info(last_name = 'Cartman', first_name = 'Eric')
# so this worked. Let's see if it becomes global or just back to when it was defined. On the levels of scope








        

#Pass a whole page for animations if this compiler would keep the coursor in veiw the whole time
#print("*"), print("*"), print("*"), print("*"), print("*"), print("*"), print("*"), print("*"), print("*"), print("*"), print("*"), print("*"), print("*"), print("*"), print("*"), print("*"), print("*"), print("*"), print("*"), print("*"), print("*"), print("*"), print("*"), print("*"), print("*"), print("*") #should be 26 lines












